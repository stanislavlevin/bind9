diff -uNr bind-8.2.2_P5/src/bin/named/ns_ctl.c bind-8.2.2_P5/src/bin/named/ns_ctl.c
--- bind-8.2.2_P5/src/bin/named/ns_ctl.c	Wed Oct 13 12:39:04 1999
+++ bind-8.2.2_P5/src/bin/named/ns_ctl.c	Mon Apr 17 15:26:29 2000
@@ -96,6 +96,9 @@
 static void		verb_getpid(struct ctl_sctx *, struct ctl_sess *,
 				    const struct ctl_verb *,
 				    const char *, u_int, const void *, void *);
+static void		verb_getargs(struct ctl_sctx *, struct ctl_sess *,
+				     const struct ctl_verb *,
+				     const char *, u_int, void *, void *);
 static void		getpid_closure(struct ctl_sctx *, struct ctl_sess *,
 				       void *);
 static void		verb_status(struct ctl_sctx *, struct ctl_sess *,
@@ -146,6 +149,7 @@
 static struct ctl_verb verbs[] = {
 	{ "",		verb_connect,	""},
 	{ "getpid",	verb_getpid,	"getpid"},
+	{ "getargs",	verb_getargs,	"getargs"},
 	{ "status",	verb_status,	"status"},
 	{ "stop",	verb_stop,	"stop"},
 	{ "exec",	verb_exec,	"exec"},
@@ -558,6 +562,36 @@
 		return;
 	}
 	sprintf(msg, "my pid is <%ld>", (long)getpid());
+	ctl_response(sess, 250, msg, 0, NULL, getpid_closure, msg, NULL, 0);
+}
+
+static void
+verb_getargs(struct ctl_sctx *ctl, struct ctl_sess *sess,
+	     const struct ctl_verb *verb, const char *rest,
+	     u_int respflags, void *respctx, void *uctx)
+{
+	char *msg = memget(MAX_STR_LEN), **argp;
+
+	if (msg == NULL) {
+		ctl_response(sess, 503, "(out of memory)", 0,
+			     NULL, NULL, NULL, NULL, 0);
+		return;
+	}
+	memset(msg, 0, MAX_STR_LEN);
+
+	strncat(msg, "my arguments are ", MAX_STR_LEN - strlen(msg) - 1);
+	strncat(msg, "<", MAX_STR_LEN - strlen(msg) - 1);
+	if((saved_argv != NULL) && (saved_argv[0] != NULL)) {
+		argp = &(saved_argv[1]);
+		while((argp != NULL) && (*argp != NULL)) {
+			strncat(msg, " ", MAX_STR_LEN - strlen(msg) - 1);
+			strncat(msg, *argp, MAX_STR_LEN - strlen(msg) - 1);
+			argp++;
+		}
+	}
+	strncat(msg, ">", MAX_STR_LEN - strlen(msg) - 1);
+
+	/* re-use getpid_closure, because a getargs_closure would be the same */
 	ctl_response(sess, 250, msg, 0, NULL, getpid_closure, msg, NULL, 0);
 }
 
diff -uNr bind-8.2.2_P5/src/bin/ndc/ndc.c bind-8.2.2_P5/src/bin/ndc/ndc.c
--- bind-8.2.2_P5/src/bin/ndc/ndc.c	Wed Oct 13 12:39:16 1999
+++ bind-8.2.2_P5/src/bin/ndc/ndc.c	Mon Apr 17 15:28:22 2000
@@ -73,6 +73,7 @@
 static void		command_channel(void);
 static void		channel_loop(char *, int, closure, void *);
 static void		getpid_closure(void *, const char *, int);
+static void		getargs_closure(void *, const char *, int);
 static void		banner(struct ctl_cctx *, void *, const char *, u_int);
 static void		done(struct ctl_cctx *, void *, const char *, u_int);
 static void		logger(enum ctl_severity, const char *fmt, ...);
@@ -278,13 +279,21 @@
 		free(syscmd);
 		return (1);
 	} else if (strncasecmp(cmd, "restart", len) == 0) {
+		char *args = NULL, *systemcmd;
+		channel_loop("getargs", quiet, getargs_closure, &args);
 		if (!running(debug, &pid))
 			error("name server was not running (warning only)");
 		else
 			stop_named(pid);
-		start_named(syscmd, save_quiet);
+		systemcmd = malloc(strlen(syscmd) +
+			           strlen(args ? args : "") +
+				   2);
+		sprintf(systemcmd, "%s %s", syscmd, args ? args : "");
+		start_named(systemcmd, save_quiet);
 		quiet = save_quiet;
 		free(syscmd);
+		free(systemcmd);
+		free(args);
 		return (1);
 	}
 	quiet = save_quiet;
@@ -362,6 +371,26 @@
 		}
 	}
 	error("response does not contain pid (%s)", text);
+}
+
+static void
+getargs_closure(void *uap, const char *text, int flags) {
+	char **args = (char **) uap;
+	const char *p, *q;
+
+	flags = flags;
+	if ((p = strchr(text, '<')) != NULL) {
+		p++;
+
+		for(q = p; (*q != '\0') && (*q != '>'); q++)
+			;
+		if (*q == '>') {
+			*args = malloc(q - p + 1);
+			memcpy(*args, p, q - p);
+			(*args)[q - p] = '\0';
+			return;
+		}
+	}
 }
 
 static void
